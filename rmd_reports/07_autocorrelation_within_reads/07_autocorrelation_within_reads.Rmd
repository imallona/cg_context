---
title: "07 autocorrelation within reads"
author: "Izaskun Mallona at Robinsonlab"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document:
    toc: true
    toc_float: true
    code_folding: hide
    code_download: true
    number_sections: true
    df_print: kable
    theme: lumen

# Aim

Postprocesses  `methtutple_bismark_read_correlation.sh`.

```
The trimming data down to 75bp limits the analysis of neighbourhood effects particularly the presence of non-CpG methylation (CpH) in the context of CpG methylation on the same strand. In other words how much is the methylation of CpGâ€™s and neighbouring CpH methylation influenced by flanking sequences on the same molecule.
```

# Set up

Knitted under `R_LIBS=/home/Shared_taupo/Rlib/release-3.11-lib /usr/local/R/R-4.0.0/bin/R`


## Libraries

```{r}
suppressPackageStartupMessages({
    library(pheatmap)
    library(knitr)
    library(ggplot2)
    library(reshape2)
    library(DT)
    library(MASS)
    library(ggExtra)
})
```

## Data load

```{r}
WD <- file.path('/home', 'Shared_s3it', 'imallona', 'cg_context',
                'nar_review', 'autocorrelation')

```

We downsize the data to:
- only `NTUPLES` tuples  (as the CNN context readouts are pretty large).
- We filter tuples with at least two methylation events within the read (to have some data for CNN). That is, those with from columns 9


```{r}

NTUPLES <- 1e8
d <- list()

header <- c('chr', 'strand', 'pos1', 'pos2', 'MM', 'MU', 'UM', 'UU',
            'region1', 'motif1', 'region2', 'motif2')

## 9 is the first tuple column
## column 72 is all unmeth, so shouldn't be included
## 69 is the last column with two Ms at least
## awk '{x=0;for(i=9;i<=69;i++) if($i>=2) x+=1; if(x>1)print}' SRR1274743_1_cutadapt_sickle_bismark_pe.CG_CHG_CHH.6.tsv | less

## awk '{x=0;for(i=9;i<=69;i++) if($i>=1) x+=1; if(x>1) print}' SRR1274743_1_cutadapt_sickle_bismark_pe.CG_CHG_CHH.6.tsv | less

## d$cg <- read.table(pipe(
##     sprintf("awk '{x=0;for(i=9;i<=69;i++) if($i>=1) x+=1; if(x>1) print}' %s",
##             file.path(WD, 'SRR1274743_1_cutadapt_sickle_bismark_pe.CG.6.tsv'))),
##     col.names = header,
##     nrows = NTUPLES)

## d$ch <- read.table(file.path(WD, 'tmp_SRR1274743_1_cutadapt_sickle_bismark.deduplicated.CG_CHG_CHH.2.tsv.gz'),
##                    col.names = header,
##                    sep = '\t',
##                    nrows = NTUPLES)

## d$cg <- read.table(file.path(WD, 'tmp_SRR1274743_1_cutadapt_sickle_bismark_pe.CG.2.tsv.gz'),
##                    col.names = header,
##                    sep = '\t',
##                    nrows = NTUPLES)


d$cnn <- read.table(file.path(WD, 'tmp_SRR1274743_chr10.CG_CHG_CHH.2.tsv.gz'),
                   col.names = header,
                   sep = '\t',
                   nrows = NTUPLES) 
```

# Collapse into frequencies


Comethylation proportion respect to the total, and not the number of tuples that at least are methylated once

```{r}
for (item in names(d)) {
    d[[item]]$dist <- d[[item]]$pos2 - d[[item]]$pos1
    d[[item]]$cometh_prop <- d[[item]]$MM/(d[[item]]$UM + d[[item]]$MU + d[[item]]$MM + d[[item]]$UU)
     ## d[[item]]$cometh_prop <- d[[item]]$MM/(d[[item]]$UM + d[[item]]$MU + d[[item]]$MM)
}
```

```{r}

lapply(d, function(x) table(x$cometh_prop == 1))
lapply(d, function(x) summary(x$cometh_prop))

```

Extract six-motifs, and filter for CG and CA contexts only

```{r}
for (item in names(d)) {
    d[[item]]$type <- paste(tolower(substr(d[[item]]$motif1, 4, 5)),
                            tolower(substr(d[[item]]$motif2, 4, 5)),
                            sep = '_')

    d[[item]]$type_simple <- 'ch_ch'
    d[[item]]$type_simple <- ifelse(
        test = (tolower(substr(d[[item]]$motif1, 4, 5)) == 'cg' |
                tolower(substr(d[[item]]$motif1, 4, 5)) == 'cg'),
        yes = 'cg_ch',
        no = 'ch_ch')
    
    d[[item]]$type_simple[d[[item]]$type == 'cg_cg'] <- 'cg_cg'

    d[[item]] <- d[[item]][d[[item]]$type %in% c('cg_cg', 'ca_cg', 'cg_ca', 'ca_ca'), ]
}


```

Extract four-motifs

```{r}
for (item in names(d)) {
    d[[item]]$four1 <- tolower(substr(d[[item]]$motif1, 3, 6))
    
    d[[item]]$four2 <- tolower(substr(d[[item]]$motif2, 3, 6))
}
```

```{r}
table(d$cnn$type)
```



```{r}
item <- 'cnn'

boxplot(list(MM = d[[item]][d[[item]]$cometh_prop == 1, 'dist'],
             UU = d[[item]][(d[[item]]$cometh_prop > 0 &
                             d[[item]]$cometh_prop < 1), 'dist'],
             UU = d[[item]][d[[item]]$cometh_prop == 0, 'dist']))
```    


<!-- Plot events of at least one methylation event by distance and by motif? -->


<!-- ```{r} -->
<!-- for (item in names(d)) { -->

<!--     plot(x = d[[item]][(d[[item]]$MM > 0 | d[[item]]$UM > 0 | d[[item]]$UM > 0), 'dist'], -->
<!--          d[[item]][(d[[item]]$MM > 0 | d[[item]]$UM > 0 | d[[item]]$UM > 0), 'cometh_prop'], -->
<!--          pch = 19, -->
<!--          col = as.numeric(as.factor( -->
<!--              d[[item]][(d[[item]]$MM > 0 | d[[item]]$UM > 0 | d[[item]]$UM > 0), -->
<!--                        'type_simple']))) -->

<!--     ss10 <- smooth.spline( -->
<!--         d[[item]][(d[[item]]$MM > 0 | d[[item]]$UM > 0 | d[[item]]$UM > 0), 'dist'], -->
<!--         d[[item]][(d[[item]]$MM > 0 | d[[item]]$UM > 0 | d[[item]]$UM > 0), 'cometh_prop']) -->
    

<!--     lines(ss10, col = "gray") -->
<!-- } -->
<!-- ``` -->


# Decay with distance

Stratified by type

```{r, fig.width = 8, fig.height= 8}
## methylated at least once
m <-  d[[item]][(d[[item]]$MM > 0 | d[[item]]$UM > 0 | d[[item]]$UM > 0),]
ggplot(m, aes(dist, cometh_prop)) + geom_point() + facet_grid(~type_simple) + 
    geom_smooth()
```

# Within reads vs across reads

Within reads

```{r}
within <- aggregate(cometh_prop ~ four1 + four2, data=d[[item]],
                    FUN = function(x) c(mean = mean(x), sd = sd(x), length = length(x)))

within <- cbind(within[-ncol(within)], within[[ncol(within)]])
colnames(within) <- c('four1', 'four2', 'cometh.mean', 'cometh.sd', 'cometh.length')

```

Overall background: per motif, get the proportion of methylated statuses. We only focus, for each tuple, in the first position, and count methylation events as MM or MU only. This we do not to check the position twice if it there are positions across multiple tuples but possibly with some shared readss, e.g. (A, B), (B, C) etc.


```{r}
## only two positions free, plus another with either C or A
stopifnot(length(unique(d$cnn$four1)) == 2 * 4^2)

bg <- data.frame(motif = unique(d$cnn$four1),
                 meth_prop.mean = NA,
                 meth_prop.sd = NA,
                 meth_prop.length = NA)

for (i in 1:nrow(bg)) {
    m <- bg[i, 'motif']
  
    curr <- d$cnn[d$cnn$four1 == m, ]

    ## bg[i,'meth_prop.mean'] = mean(curr$cometh_prop)
    ## bg[i,'meth_prop.sd'] = sd(curr$cometh_prop)
    ## bg[i,'meth_prop.length'] = length(curr$cometh_prop)
    
    bg[i,'meth_prop.mean']  <- mean((curr$MM + curr$MU)/(curr$UM + curr$MU + curr$MM + curr$UU))
    bg[i,'meth_prop.sd']  <- sd((curr$MM + curr$MU)/(curr$UM + curr$MU + curr$MM + curr$UU))
    bg[i,'meth_prop.length']  <- length((curr$MM + curr$MU)/(curr$UM + curr$MU + curr$MM + curr$UU))
    
}

```


```{r}
within <- merge(within, bg, by.x = 'four1', by.y = 'motif', suffixes = c('', '.bg1'))

colnames(within)[6:8] <- paste0('bg1.', colnames(within)[6:8])

within <- merge(within, bg, by.x = 'four2', by.y = 'motif', suffixes = c('', '.bg1'))

colnames(within)[9:11] <- paste0('bg2.', colnames(within)[9:11])

```

```{r}

table(within$cometh.mean != 0)
within <- within[within$cometh.mean != 0,]
within <- within[order(within$cometh.mean, decreasing = TRUE),]

plot(within$cometh.mean, xaxt = 'n', ylab = 'meth proportion', xlab = '', pch = 19)
axis(1, at = 1:nrow(within), las = 2, labels = paste(within$four1, within$four2, sep = '_'))

points(within$bg1.meth_prop.mean,  col = 'blue', pch = 19)
arrows(xx, low, xx, up, col = repcols, angle = 90, length = 0.03, code = 3)
## arrows(1:nrow(within), within$bg1.meth_prop.mean - within$bg1.meth_prop.sd ,
##        1:nrow(within), within$bg1.meth_prop.mean + within$bg1.meth_prop.sd,
##        code=3, length=0.02, angle = 90)

points(within$bg2.meth_prop.mean, col = 'red', pch = 19)

```

Deviations from the expectation (mean of methylation proportions either having motif1 or motif2, but not both) as compared to the observed comethylation proportions.


Only for the pairs that I measured within reads. Not necessarily across reads, but surely not contiguous and with a distance filter of MINDIST.

```{r}
MINDIST <- 150



## making sure each element within this subset is in a different read
## assumes run within a chromosome only
d$cnn$keep <- FALSE
prev_pos <- 0
for (i in 1:nrow(d$cnn)) {
        if ((d$cnn[i, 'pos1'] - prev_pos) >= MINDIST) {
            d$cnn$keep[i] <- TRUE
            prev_pos <- d$cnn[i, 'pos1']
        }
}

```

```{r}
table(d$cnn$keep)
```
          

```{r}

across <- data.frame(four1 = within$four1,
                     four2 = within$four2,
                     cometh.mean = NA,
                     cometh.sd = NA,
                     cometh.length = NA)

for (i in 1:nrow(across)) {
        m1 <- across[i, 'four1']
        m2 <- across[i, 'four2']
        curr <- d$cnn[d$cnn$keep & ((d$cnn$four1 == m1 & d$cnn$four2 != m2) |
                      (d$cnn$four1 == m2 & d$cnn$four2 != m1)), ]
        
   
        across[i,'cometh.mean'] = mean(curr$cometh_prop)
        across[i,'cometh.sd'] = sd(curr$cometh_prop)
        across[i,'cometh.length'] = length(curr$cometh_prop)
}

    
```


```{r}
plot(x = across$cometh.mean, y = within$cometh.mean, pch = 19)

plot(x = log(across$cometh.mean), y = log(within$cometh.mean), pch = 19,
     xlim = c(-10, -2), ylim = c(-10, -2))

lines(x = c(-10,-2), y = c(-10, -2))

## Split for CG, CA, and CGCA
```

```{r}
save('all.RData', list = c('d', 'across', 'within'))
```

```{r}
## ## only two positions free, plus another with either C or A
## stopifnot(length(unique(d$cnn$four1)) == 2 * 4^2)

## ## we'll only fill the same data we got for within reads

## agg_across <- data.frame(four1 = agg_within$four1,
##                          four2 = agg_within$four2,
##                          cometh_prop.mean = NA,
##                          cometh_prop.sd = NA,
##                          cometh_prop.length = NA)

## for (i in 1:nrow(agg_across)) {
##     m1 <- agg_across[i, 'four1']
##     m2 <- agg_across[i, 'four2']
##     curr <- d$cnn[(d$cnn$four1 == m1 & d$cnn$four2 != m2) |
##                   (d$cnn$four1 == m2 & d$cnn$four2 != m1), ]
    
##     agg_across[i,'cometh_prop.mean'] = mean(curr$cometh_prop)
##     agg_across[i,'cometh_prop.sd'] = sd(curr$cometh_prop)
##     agg_across[i,'cometh_prop.length'] = length(curr$cometh_prop)  
## }

```

```{r}
plot(agg_within$cometh_prop.mean, agg_across$cometh_prop.mean)
```


Across reads

```{r}


```


<!-- ```{r} -->
<!-- p <- ggplot(m[m$type_simple == 'cg_cg',], aes(dist, cometh_prop)) + -->
<!--     geom_point() + -->
<!--         xlab('') + -->
<!--         ylab('') + -->
<!--     theme(legend.position = "none") -->

<!-- ggMarginal(p, margins = 'y', -->
<!--            groupColour = FALSE, groupFill = FALSE) -->

<!-- ``` -->

<!-- Now plot according to the nucleotide in the key position. -->

<!-- ```{r} -->

<!-- library(hexbin) -->
<!-- library(RColorBrewer) -->
<!-- rf <- colorRampPalette(rev(brewer.pal(11,'Spectral'))) -->
<!-- r <- rf(32) -->

<!-- h <- hexbin(d$cg[,c('dist', 'cometh_prop')]) -->
<!-- plot(h, colramp = rf) -->

<!-- ``` -->

<!-- ```{r} -->
<!-- d$cg$logdist <- log(d$cg$dist +1, base = 10) -->
<!-- d$cg$asin_cometh_prop <- asin(d$cg$cometh_prop) -->

<!-- hlog <- hexbin(d$cg[,c('dist', 'asin_cometh_prop')]) -->
<!-- plot(hlog, colramp = rf) -->
<!-- ``` -->



<!-- ```{r} -->
<!-- prop <- list() -->

<!-- for (item in names(d)) { -->
<!--     tuples <- grep('M|U', header, value = TRUE) -->
    
<!--     prop[[item]] <- data.frame(prop = colSums(d[[item]][,tuples]) / sum(d[[item]][,tuples]), -->
<!--                                status = tuples) -->

   
<!-- } -->
<!-- ``` -->


<!-- ```{r} -->

<!-- plot(y = prop$cg$prop, x = 1:nrow(prop$cg), xaxt = 'n', xlab = '', type ='p', col = 'blue', -->
<!--      pch = 0) -->
<!-- lines(y = prop$mixed$prop, x = 1:nrow(prop$cg), type ='p', pch = 4) -->

<!-- axis(1, at = 1:nrow(prop$cg), labels = prop$cg$status, las = 2) -->
<!-- ``` -->


<!-- ```{r} -->

<!-- plot(y = prop$cg$logprop, x = 1:nrow(prop$cg), xaxt = 'n', xlab = '', type ='p', -->
<!--      col = 'blue', pch = 0, ylim = c(min(min(prop$cg$logprop, prop$mixed$logprop)), -->
<!--                                      max(max(prop$cg$logprop, prop$mixed$logprop)))) -->

<!-- lines(prop$mixed$logprop, x = 1:nrow(prop$mixed), type ='p', pch = 4) -->
      
<!-- axis(1, at = 1:nrow(prop$cg), labels = prop$cg$status, las = 2) -->
<!-- ``` -->

<!-- Plot proportion of Ms vs distance between them -->

<!-- first get the tuples that are different from 0 -->
<!-- then get the coordinates -->
<!-- then get the distance between all possible pairs of Ms -->


<!-- ```{r} -->
<!-- dists <- list() -->
<!-- for (item in names(d)) { -->
<!--     dists[[tuple]] <- list() -->
<!--     for (tuple in tuples) { -->
<!--         ## at least two methylation events -->
<!--         if (length(grep('M', strsplit(tuple, '')[[1]])) >= 2) { -->
<!--             ## this gets the relative position of an `M` within a tuple, e.g. UMMMU -> 2,3,4 -->
<!--             ## grep('M', strsplit(tuple, '')[[1]]) -->
<!--             ## this the coordinates of those -->
<!--             ## d[[item]][,paste0('pos', grep('M', strsplit(tuple, '')[[1]]))] -->
<!--             ## and this the distances between the leftmost and all other events -->
            
<!--             dists[[item]][[tuple]] <- apply(d[[item]][,paste0('pos', grep('M', strsplit(tuple, '')[[1]]))], 2, -->
<!--                                             function(x) return(x -d[[item]][,paste0('pos', grep('M', strsplit(tuple, '')[[1]]))][,1])) -->
            
<!--         } -->
<!--     } -->
<!-- } -->

<!-- ``` -->


<!-- ```{r} -->

<!-- item <- 'cg' -->
<!-- curr <- 'MMUUUU' -->

<!-- plot(x= as.vector(dists[[item]][[curr]]), y=prop[[item]][[curr]]$prop) -->

<!-- ``` -->

# Export objects


# Timestamp

```{r sessionInfo, cache = FALSE}
date()
sessionInfo()
devtools::session_info()

```
