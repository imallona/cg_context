---
title: "03_stats_assessment CG and CH seq preferences (no coverage filtering)"
author: "Izaskun Mallona"
output:
  html_document:
    keep_md: true
    toc: true
    toc_float: true
    toc_depth: 4
params:
  seed: 11

---

Requires `02_motif_extract_run_nov_2019_no_coverage_filtering_postproc.Rmd` to be run first.

Motifs are classified as methylated or unmethylated and counted, without aggregating average methylation values per sample to avoid batch/genotype effects.

Started 27 Feb 2020

# Config


```{r settings, include=FALSE}
library(knitr)
## library(devtools)
## library(reshape2)
## library(lattice)
## library(pheatmap)
## library(seqLogo)
## library(margins)
## library(data.table)
library(ggplot2)
## library(ggfortify)
## library(ggseqlogo)
## library(gridExtra)
library(DT)
## library(naivebayes)
## library(viridis)
## suppressPackageStartupMessages(library(dendextend))
library(AMR) # gtest
```

```{r}
opts_chunk$set(fig.width = 8,
               fig.height = 8,
               cache = TRUE,
               include = TRUE,
               cache.lazy = FALSE,
               warning = TRUE,
               message = TRUE)



```

# Data retrieval

The object was generated by  `02_motif_extract_run_nov_2019_no_coverage_filtering_postproc.Rmd`

It is tracked at `./data/counts_nested_list.RData` as well

```{r}
con <- url('http://imlstaupo.uzh.ch/imallona/baubec/cg_context/counts_nested_list.RData')
load(con)
close(con)
```

# Permutation analysis on `tko+d3a2_merged`

## CG

Permute motifs keeping the (meth, unmeth tuples)

```{r, d3acg}

## stopifnot(all(d$cg$`tko+d3a2_merged`$meth$motif == d$cg$`tko+d3a2_merged`$unmeth$motif))

## a <- data.frame(motif = d$cg$`tko+d3a2_merged`$meth$motif,
##                 meth = d$cg$`tko+d3a2_merged`$meth$count,
##                 unmeth = d$cg$`tko+d3a2_merged`$unmeth$count)

## keeping_meth_and_unmeth_blocks
permute_motifs <- function(fd, n = 1000) {

    res <- list()
    for (i in 1: n) {
        idx <- sample(x = rownames(fd), size = nrow(fd), replace = FALSE)
        res[[i]] <- data.frame(motif = fd$motif,
                               meth = fd[idx, 'meth'],
                               unmeth = fd[idx, 'unmeth'])
    }
    return(res)
}


permute_2d <- function(fd, n = 1000) {
    res <- list()
    for (i in 1: n) {
        idx <- sample(x = rownames(fd), size = nrow(fd), replace = FALSE)
        idx2 <- sample(x = rownames(fd), size = nrow(fd), replace = FALSE)
        res[[i]] <- data.frame(motif = fd$motif,
                               meth = fd[idx, 'meth'],
                               unmeth = fd[idx2, 'unmeth'])

        res[[i]]$score <- 
    }
    return(res)
}


run_permutation_test <- function(fd, permutation_type, n = 1000) {
    if (permutation_type == 'motifs')
        res <- permute_motifs(fd, n)
    else if (permutation_type = '2d')
        res <- permute_2d(fd, n)
    else
        stop('wrong permutation type')

    for (motif in rownames(fd){
        apply(fd, 1, function(x) x$meth/(x$meth + x$unmeth) > fd$meth/(fd$meth + fd$unmeth))
        
    }
     
}

```    

Permute independently meth and unmeth tuples to remove conversion biases?

# Prop test?


##  CG


We'll check the methylation success per motif according to the enzyme added back.

G test and not Chisq-test due to the moderately high events (meth or unmeth counts)?

Prop test?

Binom test with just successes?

@Mark 


```{r}

stopifnot(all(d$cg$`tko+d3a2_merged`$meth$motif == d$cg$`tko+d3a2_merged`$unmeth$motif))

a <- data.frame(motif = d$cg$`tko+d3a2_merged`$meth$motif,
                meth = d$cg$`tko+d3a2_merged`$meth$count,
                unmeth = d$cg$`tko+d3a2_merged`$unmeth$count)

rownames(a) <- a$motif

stopifnot(all(d$cg$`tko+d3b1_merged`$meth$motif == d$cg$`tko+d3b1_merged`$unmeth$motif))

b <- data.frame(motif = d$cg$`tko+d3b1_merged`$meth$motif,
                meth = d$cg$`tko+d3b1_merged`$meth$count,
                unmeth = d$cg$`tko+d3b1_merged`$unmeth$count)

rownames(b) <- b$motif

stopifnot(all(d$cg$`tko+da3a2_merged`$meth$motif == d$cg$`tko+d3b1_merged`$unmeth$motif))
```

Assuming independences and H0: methylation proportion in DNMT3A and DNMT3b are the same, iterating all motifs as follows?

```{r}

prop_test_to_iterate <- function(a, b, motif) {
    curr <- as.data.frame(matrix(data = NA, nrow = 2, ncol = 2))
    
    curr[1,] <- as.numeric(a[motif, c('meth', 'unmeth')])
    curr[2,] <- as.numeric(b[motif, c('meth', 'unmeth')])
    
    colnames(curr) <- c('meth', 'unmeth')
    rownames(curr) <- sprintf('%s_%s', motif, c('a', 'b'))
    
    return(list(table = curr,
                test = prop.test(x = curr$meth, n = curr$meth + curr$unmeth)))
}

prop_test_to_iterate(a = a, b = b, motif = 'AAACGAAA')
prop_test_to_iterate(a = a, b = b, motif = 'AAACGAAT')
prop_test_to_iterate(a = a, b = b, motif = 'AAACGCGC')

```

```{r}

res <- list()

for (motif in a$motif) {
    res[[motif]] <- prop_test_to_iterate(a = a, b = b, motif = motif)
}

print('padjust FDR correct')
```


# Timestamp

```{r sessionInfo, cache = 0}
date()
sessionInfo()
devtools::session_info()

```
