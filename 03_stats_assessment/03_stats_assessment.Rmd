---
title: "03_stats_assessment CG and CH seq preferences (no coverage filtering)"
author: "Izaskun Mallona"
output:
  html_document:
    keep_md: true
    toc: true
    toc_float: true
    toc_depth: 4
params:
  seed: 11

---

Requires `02_motif_extract_run_nov_2019_no_coverage_filtering_postproc.Rmd` to be run first.

Motifs are classified as methylated or unmethylated and counted, without aggregating average methylation values per sample to avoid batch/genotype effects.

Started 27 Feb 2020

# Config


```{r settings, include=FALSE}
library(knitr)
## library(devtools)
## library(reshape2)
## library(lattice)
## library(pheatmap)
## library(seqLogo)
## library(margins)
## library(data.table)
library(ggplot2)
## library(ggfortify)
## library(ggseqlogo)
## library(gridExtra)
library(DT)
## library(naivebayes)
## library(viridis)
## suppressPackageStartupMessages(library(dendextend))
library(AMR) # gtest
```

```{r}
opts_chunk$set(fig.width = 8,
               fig.height = 8,
               cache = TRUE,
               include = TRUE,
               cache.lazy = FALSE,
               warning = TRUE,
               message = TRUE)



```

# Data retrieval

The object was generated by  `02_motif_extract_run_nov_2019_no_coverage_filtering_postproc.Rmd`

It is tracked at `./data/counts_nested_list.RData` as well

```{r}
con <- url('http://imlstaupo.uzh.ch/imallona/baubec/cg_context/counts_nested_list.RData')
load(con)
close(con)
```

# Permutation analysis on `tko+d3a2_merged`

## CG

Permute motifs keeping the (meth, unmeth tuples)

```{r, d3acg}

## stopifnot(all(d$cg$`tko+d3a2_merged`$meth$motif == d$cg$`tko+d3a2_merged`$unmeth$motif))

## a <- data.frame(motif = d$cg$`tko+d3a2_merged`$meth$motif,
##                 meth = d$cg$`tko+d3a2_merged`$meth$count,
##                 unmeth = d$cg$`tko+d3a2_merged`$unmeth$count)

## keeping_meth_and_unmeth_blocks
permute_motifs <- function(fd, n = 1000) {

    res <- list()
    for (i in 1: n) {
        idx <- sample(x = rownames(fd), size = nrow(fd), replace = FALSE)
        res[[i]] <- data.frame(motif = fd$motif,
                               meth = fd[idx, 'meth'],
                               unmeth = fd[idx, 'unmeth'])

        rownames(res[[i]]) <- res[[i]]$motif

        res[[i]]$score <- res[[i]]$meth / (res[[i]]$meth  + res[[i]]$unmeth)

    }
    return(res)
}


permute_2d <- function(fd, n = 1000) {
    res <- list()
    for (i in 1: n) {
        idx <- sample(x = rownames(fd), size = nrow(fd), replace = FALSE)
        idx2 <- sample(x = rownames(fd), size = nrow(fd), replace = FALSE)
        res[[i]] <- data.frame(motif = fd$motif,
                               meth = fd[idx, 'meth'],
                               unmeth = fd[idx2, 'unmeth'])

        rownames(res[[i]]) <- res[[i]]$motif

        res[[i]]$score <- res[[i]]$meth / (res[[i]]$meth  + res[[i]]$unmeth)
    }
    
    return(res)
}

## note that permutation p-values should never be 0;
## we add `1` to the one-tailed test to include the observation on top to the
##   number of permutations
run_permutation_test <- function(fd, permutation_type, n = 1000, adjust.FDR = TRUE) {
    if (permutation_type == 'motifs') {
        res <- permute_motifs(fd, n)
    }
    else if (permutation_type == '2d') {
        res <- permute_2d(fd, n)
    }
    else {
        stop('wrong permutation type')
    }

    fd$pval <- NA
    fd$qval <- NA
    
    for (motif in rownames(fd)){
        fd[motif, 'pval'] <- (sum(
            sapply(res,
                   function(x) fd[motif,]$score <= x[motif,]$score)) + 1) / (n + 1)
        if(fd[motif, 'pval'] > 1) stop()
       
    }

    if (adjust.FDR) {
        fd$qval <- p.adjust(fd$pval, method = 'BH')
    }

    return(fd)     
}


```

# Permutation analysis on `tko+d3a2_merged`

Permuting motifs in DNMT D3A2 

```{r}
stopifnot(all(d$cg$`tko+d3a2_merged`$meth$motif == d$cg$`tko+d3a2_merged`$unmeth$motif))

a <- data.frame(motif = d$cg$`tko+d3a2_merged`$meth$motif,
                meth = d$cg$`tko+d3a2_merged`$meth$count,
                unmeth = d$cg$`tko+d3a2_merged`$unmeth$count)

rownames(a) <- a$motif
a$score <- a$meth / (a$meth + a$unmeth)
head(a$score)

a_motif_perm <- run_permutation_test(fd = a,
                                     n = 200,
                                     permutation_type = 'motifs',
                                     adjust.FDR = TRUE)


summary(a_motif_perm)
table(a_motif_perm$pval < 0.05)
table(a_motif_perm$qval < 0.05)
```

Permuting meth and unmeth counts in DNMT D3A2

```

a_all_perm <- run_permutation_test(fd = a,
                                   n = 200,
                                   permutation_type = '2d',
                                   adjust.FDR = TRUE)

summary(a_all_perm)
table(a_all_perm$pval < 0.05)
table(a_all_perm$qval < 0.05)

```

Comparing both permutation strategies.

```{r}

par(mfrow = c(2,2))
hist(a_motif_perm$pval)
hist(a_all_perm$pval)

plot(a_motif_perm$pval, a_all_perm$pval)

plot(a_motif_perm$pval[a_motif_perm$pval < 0.05 | a_all_perm$pval < 0.05 ],
     a_all_perm$pval[a_motif_perm$pval < 0.05 | a_all_perm$pval < 0.05 ])
```


## Permutation analysis on `tko+d3b1_merged`

Data reshaping for tko+d3b1


```{r}
b <- data.frame(motif = d$cg$`tko+d3b1_merged`$meth$motif,
                meth = d$cg$`tko+d3b1_merged`$meth$count,
                unmeth = d$cg$`tko+d3b1_merged`$unmeth$count)

rownames(b) <- b$motif
b$score <- b$meth / (b$meth + b$unmeth)
head(b$score)

```


Permuting motifs in tko+d3b1

```{r}
b_motif_perm <- run_permutation_test(fd = b,
                                     n = 200,
                                     permutation_type = 'motifs',
                                     adjust.FDR = TRUE)


summary(b_motif_perm)
table(b_motif_perm$pval < 0.05)
table(b_motif_perm$qval < 0.05)
```

Permuting meth and unmeth counts for tko+d3b1

```{r}

b_all_perm <- run_permutation_test(fd = b,
                                   n = 200,
                                   permutation_type = '2d',
                                   adjust.FDR = TRUE)

summary(b_all_perm)
table(b_all_perm$pval < 0.05)
table(b_all_perm$qval < 0.05)
```

Comparing both permutation strategies.

```{r}
par(mfrow = c(2,2), pty = 's')
hist(b_motif_perm$pval)
hist(b_all_perm$pval)

plot(b_motif_perm$pval, b_all_perm$pval)

plot(b_motif_perm$pval[b_motif_perm$pval < 0.05 | b_all_perm$pval < 0.05 ],
     b_all_perm$pval[b_motif_perm$pval < 0.05 | b_all_perm$pval < 0.05 ])
```

## Comparing DNMT3A and DNMT3B meth preferences according to the permutation outputs

```{r}
par(mfrow = c(1,2), pty = 's')

plot(a_motif_perm$pval, b_motif_perm$pval)
plot(a_all_perm$qval, b_all_perm$qval)

```
     
# By proportion tests


##  CG


We'll check the methylation success per motif according to the enzyme added back. We'll directly compare DNMT3A and DNMT3B.

Because of the upper plot (section `Comparing DNMT3A and DNMT3B meth preferences according to the permutation outputs`) it's expected that success rate (proportion of methylated vs unmethylated) for most of the motifs will be different. The H0 (null of proportions being the same in DNMT3A and DNMT3B) will most probably be rejected for most cases.


```{r}
stopifnot(all(d$cg$`tko+da3a2_merged`$meth$motif == d$cg$`tko+d3b1_merged`$unmeth$motif))
```

Assuming independences and H0: methylation proportion in DNMT3A and DNMT3b are the same, iterating all motifs as follows?

```{r}

prop_test_to_iterate <- function(a, b, motif) {
    curr <- as.data.frame(matrix(data = NA, nrow = 2, ncol = 2))
    
    curr[1,] <- as.numeric(a[motif, c('meth', 'unmeth')])
    curr[2,] <- as.numeric(b[motif, c('meth', 'unmeth')])
    
    colnames(curr) <- c('meth', 'unmeth')
    rownames(curr) <- sprintf('%s_%s', motif, c('a', 'b'))
    
    return(list(table = curr,
                test = prop.test(x = curr$meth, n = curr$meth + curr$unmeth, correct = TRUE)))
}

## reto <-prop_test_to_iterate(a = a, b = b, motif = 'AAACGAAA')
## prop_test_to_iterate(a = a, b = b, motif = 'AAACGAAT')
## prop_test_to_iterate(a = a, b = b, motif = 'AAACGCGC')

```

```{r}

ptests_list <- list()

for (motif in a$motif) {
    ptests_list[[motif]] <- prop_test_to_iterate(a = a, b = b, motif = motif)
}


ptests <- data.frame(motif = names(sapply(ptests_list, function(x) return(x$test$p.value))),
                  pval = as.numeric(sapply(ptests_list, function(x) return(x$test$p.value))))

rownames(ptests) <- ptests$motif

ptests$qval <- p.adjust(ptests$pval, method = 'BH')

table(ptests$qval < 0.05)

```

```{r}
par(mfrow = c(1,2), pty = 's')
hist(prop.tests$pval)
hist(prop.tests$qval)

```

## Plot z-scores and plot the delta A-B as well to grasp the extent of the change.



```{r zscores}

## modified from gCMAP::zScores
zscore_from_pval <- function (pval, direction = NULL, tails = 1, limit = .Machine$double.xmin){ 
    if (!is.null(limit)) {
        pval[which(pval < limit)] <- limit
    }
    if (tails == 2) {
        z <- qnorm(pval/2, lower.tail = FALSE)
    }
    else if (tails == 1) {
        z <- qnorm(pval, lower.tail = FALSE)
    }
    else {
        stop("Parameter 'tails' must be set to either 1 or 2.")
    }

    ## direction of change
    if (!is.null(direction)) {
        z <- z * sign(direction)
    }
    return(z)
}


```


```{r, eval = TRUE}
prop.tests$delta <- a[rownames(prop.tests), 'score'] - b[rownames(prop.tests), 'score']
prop.tests$ascore <-  a[rownames(prop.tests), 'score']
prop.tests$bscore <- b[rownames(prop.tests), 'score']
prop.tests$zscore <- zscore_from_pval(prop.tests$pval, direction = prop.tests$delta, tails = 2)

summary(prop.tests)

## plot(prop.tests)
par(mfrow = c(2,2), pty = 's')

plot(prop.tests$delta, prop.tests$zscore, pch = 19)
plot(prop.tests$ascore, prop.tests$zscore, pch = 19)
plot(prop.tests$bscore, prop.tests$zscore, pch = 19)

```

Sort the motifs by their zscore and then the delta of the scores, and plot the trends


```{r}
prop.tests <- prop.tests[order(abs(prop.tests$zscore), prop.tests$delta,
                               decreasing = TRUE),]
prop.tests$zscore_rank <- 1:nrow(prop.tests)

par(mfrow = c(2,2), pty = 's')
plot(y = abs(prop.tests$zscore), x = prop.tests$zscore_rank)
plot(y = abs(prop.tests$delta), x = prop.tests$zscore_rank)
plot(y = abs(prop.tests$bscore), x = prop.tests$zscore_rank)
plot(y = abs(prop.tests$ascore), x = prop.tests$zscore_rank)

```

# Timestamp

```{r sessionInfo, cache = 0}
date()
sessionInfo()
devtools::session_info()

```
