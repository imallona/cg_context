---
title: "04_stats_assessment CG and CH seq preferences (no coverage filtering)"
author: "Izaskun Mallona"
output:
  html_document:
    keep_md: true
    toc: true
    toc_float: true
    toc_depth: 4
params:
  seed: 11

---

Requires `02_motif_extract_run_nov_2019_no_coverage_filtering_postproc.Rmd` to be run first.

Motifs are classified as methylated or unmethylated and counted, without aggregating average methylation values per sample to avoid batch/genotype effects.

Started 11 March 2020

# Config

<details><summary>Expand</summary>

Libraries, knitr options, permutation numbers, threads.

```{r settings, include=FALSE}
library(knitr)
library(ggplot2)
library(gridExtra)
library(ggExtra)
library(DT)
library(doParallel)
library(dplyr)
library(EnsCat)
library(ggtree)
library(dplyr)
library(treeclimbR)  
library(ape)
library(diffcyt)
library(ggnewscale)
library(treeio)
## devtools::install_github('fionarhuang/TreeSummarizedExperiment', ref = 'master')
library(TreeSummarizedExperiment, lib.loc = '/home/imallona/R/x86_64-pc-linux-gnu-library/3.6')

```

```{r}
opts_chunk$set(fig.width = 5,
               fig.height = 5,
               dpi = 200,
               cache = TRUE,
               include = TRUE,
               cache.lazy = FALSE,
               warning = TRUE,
               message = TRUE)



```


```{r}
options(bitmapType="cairo")

```

```{r}
NUM_PERM = 10000
NTHREADS <- 20
```

</details>

# Data retrieval

The object was generated by  `02_motif_extract_run_nov_2019_no_coverage_filtering_postproc.Rmd`

```{r}
con <- url('http://imlstaupo.uzh.ch/imallona/baubec/cg_context/counts_nested_list.RData')
load(con)
close(con)
```

## Permutation analysis on `tko+d3a2_merged`

To check whether the proportion of methylated sites versus the unmethylated sites (or versus the coverage), we need to run a test that maintains the average DNA methylation of that sample.


- (permute motifs strategy)  permuting the motifs a certain number of times.


<details><summary>Expand the permutation test implementation</summary>

```{r, d3acg, cache = FALSE}

## keeping_meth_and_unmeth_blocks
permute_motifs <- function(fd, numperm = 1000, nthreads = NTHREADS) {

    res <- list()

    cl <- makeCluster(nthreads) #,

    registerDoParallel(cl)

    res <- foreach(i = 1:numperm) %dopar% {
        idx <- sample(x = rownames(fd), size = nrow(fd), replace = FALSE)
        tmp  <- data.frame(motif = fd$motif,
                           meth = fd[idx, 'meth'],
                           unmeth = fd[idx, 'unmeth'])

        rownames(tmp) <- tmp$motif

        tmp <- data.frame(motif = as.character(tmp$motif),
                          meth = tmp$meth,
                          unmeth = tmp$unmeth,                   
                          score = tmp$meth / (tmp$meth  + tmp$unmeth),
                          stringsAsFactors = FALSE)
        rownames(tmp) <- tmp$motif
	tmp
    }

    stopCluster(cl)
    rm(cl)
    
    return(res)
}


## note that permutation p-values should never be 0;
## we add `1` to the one-tailed test to include the observation on top to the
##   number of permutations
run_permutation_test <- function(fd, permutation_type, numperm = 1000, adjust.FDR = TRUE,
                                 nthreads = NTHREADS) {
    if (permutation_type == 'motifs') {
        res <- permute_motifs(fd = fd, numperm = numperm, nthreads = nthreads)
    }
    else if (permutation_type == '2d') {
        res <- permute_2d(fd, numperm = numperm, nthreads = nthreads)
    }
    else {
        stop('wrong permutation type')
    }

    fd$pval <- NA
    fd$qval <- NA ## Benjamini Hochberg corrected p-val

    cl <- makeCluster(nthreads)
   
    doParallel::registerDoParallel(cl)

    ## save(res, file = 'res.RData')
   
    foo <- foreach(i = 1:nrow(fd))  %dopar% {
        motif <- rownames(fd)[i]
        tmp <- data.frame (pval = (sum(
            sapply(res,
                   function(x) fd[motif,]$score < x[motif,]$score)) + 1) / (numperm),
            motif = motif)
        tmp

    }

    ## save(foo, file = 'foo.Rdata')

    fd$pval <- sapply(foo, function(x) return (x$pval))
    fd$pval[fd$pval > 1] <- 1

   
    stopCluster(cl)
    rm(cl)

    if (adjust.FDR) {
        fd$qval <- p.adjust(fd$pval, method = 'BH')
    }

    return(fd)      
}


```
</details>

# Permutation analysis on `tko+d3a2_merged`

## Permuted motifs

Permuting motifs in DNMT D3A2 

```{r}
stopifnot(all(d$cg$`tko+d3a2_merged`$meth$motif == d$cg$`tko+d3a2_merged`$unmeth$motif))

a <- data.frame(motif = d$cg$`tko+d3a2_merged`$meth$motif,
                meth = d$cg$`tko+d3a2_merged`$meth$count,
                unmeth = d$cg$`tko+d3a2_merged`$unmeth$count)

rownames(a) <- a$motif
a$score <- a$meth / (a$meth + a$unmeth)

a_motif_perm <- run_permutation_test(fd = a,
                                     numperm = NUM_PERM,
                                     permutation_type = 'motifs',
                                     adjust.FDR = TRUE,
                                     nthreads = NTHREADS)

```

How many motifs reject the null hypothesis _methylation score is lower than the methylation score randomly drawed from the motifs_? Null hypothesis rejection (p <0.05) indicate that a motif score (methylation status) is higher than the backgound.



```{r}
table(a_motif_perm$pval < 0.05)
```

How many are significant after FDR (Benjamini Hochberg) multiple testing correction?

```{r}
table(a_motif_perm$qval < 0.05)
```

```{r}
DT::datatable(a_motif_perm %>% as.data.frame() %>% 
              dplyr::mutate_if(is.numeric, funs(round(., 2))), 
              extensions = c("Buttons", "FixedColumns"),
              rownames = FALSE, 
              options = list(dom = "Bfrtip",
                             scrollX = TRUE, 
                             fixedColumns = list(leftColumns = 1),
                             buttons = c("csv", "excel")))
```    

Plots with marginals


```{r}
p <- ggplot(a_motif_perm, aes(y = score, x = pval)) +
    geom_point() +
    theme_classic(base_size = 20) +
    ylab('methylation score') +
    xlab('p-value (permuted motifs)') +
    ggtitle('DNMT3A2')

ggMarginal(p, type = "histogram", bins = 10, colour = 'black')#, groupColour = TRUE)

```


```{r}
p <- ggplot(a_motif_perm, aes(x=qval, y=score)) +
    geom_point() +
    theme_classic(base_size = 20) +
    ylab('methylation score') +
    xlab ('FDR (permuted motifs)') +
    ggtitle('DNMT3A2')

ggMarginal(p, type = "histogram", bins = 10, colour = 'black')

```


## Unadjusted p values distribution

```{r}

hist(a_motif_perm$pval)

```

# Permutation analysis on `tko+d3b1_merged`

Data reshaping for tko+d3b1


```{r}
b <- data.frame(motif = d$cg$`tko+d3b1_merged`$meth$motif,
                meth = d$cg$`tko+d3b1_merged`$meth$count,
                unmeth = d$cg$`tko+d3b1_merged`$unmeth$count)

rownames(b) <- b$motif
b$score <- b$meth / (b$meth + b$unmeth)

```

## Permuting motifs

Permuting motifs in tko+d3b1

```{r}
b_motif_perm <- run_permutation_test(fd = b,
                                     numperm = NUM_PERM,
                                     permutation_type = 'motifs',
                                     adjust.FDR = TRUE,
                                     nthreads = NTHREADS)


```

How many motifs reject the null hypothesis _methylation score is lower than the methylation score randomly drawed from the motifs_? Null hypothesis rejection (p <0.05) indicate that a motif score (methylation status) is higher than the backgound.

```{r}
table(b_motif_perm$pval < 0.05)
```

How many are higher after FDR (Benjamini Hochberg) multiple testing correction?

```{r}
table(b_motif_perm$qval < 0.05)
```


```{r}
DT::datatable(b_motif_perm %>% as.data.frame() %>% 
              dplyr::mutate_if(is.numeric, funs(round(., 2))), 
              extensions = c("Buttons", "FixedColumns"),
              rownames = FALSE, 
              options = list(dom = "Bfrtip",
                             scrollX = TRUE, 
                             fixedColumns = list(leftColumns = 1),
                             buttons = c("csv", "excel")))
```

```{r}
p <- ggplot(b_motif_perm, aes(y = score, x = pval)) +
    geom_point() +
    theme_classic(base_size = 20) +
    ylab('methylation score') +
    xlab('p-value (permuted motifs)') +
    ggtitle('DNMT3B1')

ggMarginal(p, type = "histogram", bins = 10, colour = 'black')#, groupColour = TRUE)

```


```{r}
p <- ggplot(b_motif_perm, aes(x=qval, y=score)) +
    geom_point() +
    theme_classic(base_size = 20) +
    ylab('methylation score') +
    xlab ('FDR (permuted motifs)') +
    ggtitle('DNMT3B1')

ggMarginal(p, type = "histogram", bins = 10, colour = 'black')

```


## Unadjusted p values distribution

```{r}

hist(b_motif_perm$pval)

```

# Comparing DNMT3A and DNMT3B's  permutation results


```{r}
p <- ggplot(data = data.frame(pval_a = a_motif_perm$pval,
                              pval_b = b_motif_perm$pval),
                aes(x=pval_a, y = pval_b)) +
    geom_point() +
    theme_classic(base_size = 20) +
    ylab('pval D3A2') +
    xlab ('pval D3B1') + ggtitle('permuted motifs')


ggMarginal(p, type = "histogram", bins = 10, colour = 'black')
    

```


```{r}
p <- ggplot(data = data.frame(qval_a = a_motif_perm$qval,
                              qval_b = b_motif_perm$qval),
                aes(x=qval_a, y = qval_b)) +
    geom_point() +
    theme_classic(base_size = 20) +
    ylab('FDR D3A2') +
    xlab ('FDR D3B1') + ggtitle('permuted motifs')


ggMarginal(p, type = "histogram", bins = 10, colour = 'black')
    

```


# DNMT3A vs DNMT3B by proportion tests

We'll check the methylation success per motif according to the enzyme added back. We'll directly compare DNMT3A and DNMT3B.

Success: number of times a motif is methylated.
Failure: number of times a motif is not methylated.


As depicted by the previous plots, it's expected that success rate (proportion of methylated vs unmethylated) for most of the motifs will be different. The H0 (null of proportions being the same in DNMT3A and DNMT3B) will most probably be rejected for most cases.


```{r}
stopifnot(all(d$cg$`tko+da3a2_merged`$meth$motif == d$cg$`tko+d3b1_merged`$unmeth$motif))
```

Assuming independences and H0: methylation proportion in DNMT3A and DNMT3b are the same, iterating all motifs as follows?

<details><summary>Expand proportion tests implementation.</summary>

```{r}

prop_test_to_iterate <- function(a, b, motif) {
    curr <- as.data.frame(matrix(data = NA, nrow = 2, ncol = 2))
    
    curr[1,] <- as.numeric(a[motif, c('meth', 'unmeth')])
    curr[2,] <- as.numeric(b[motif, c('meth', 'unmeth')])
    
    colnames(curr) <- c('meth', 'unmeth')
    rownames(curr) <- sprintf('%s_%s', motif, c('a', 'b'))
    
    return(list(table = curr,
                test = prop.test(x = curr$meth, n = curr$meth + curr$unmeth, correct = TRUE)))
}

## prop_test_to_iterate(a = a, b = b, motif = 'AAACGCGC')

```

</details>

```{r}

ptests_list <- list()

for (motif in a$motif) {
    ptests_list[[motif]] <- prop_test_to_iterate(a = a, b = b, motif = motif)
}


ptests <- data.frame(motif = names(sapply(ptests_list, function(x) return(x$test$p.value))),
                  pval = as.numeric(sapply(ptests_list, function(x) return(x$test$p.value))))

rownames(ptests) <- ptests$motif

ptests$qval <- p.adjust(ptests$pval, method = 'BH')

```

How many motifs show methylation success rates (proportion of methylated counts vs unmethylated counts) that are similar for DNMT3A and DNMT3B?

```{r}
table(ptests$pval < 0.05)

```

Is it as high after BH-adjustment?

```{r}
table(ptests$qval < 0.05)

```

How were p-values distributed originally? Not uniform, BH does not apply.

```{r, fig.height = 4, fig.width = 8}
par(mfrow = c(1,2), pty = 's')
hist(ptests$pval)
hist(ptests$qval)

```

## Plot z-scores and plot the score difference DNMTA- DNMTB 

We could retrieve the z-scores from the unadjusted p-values from the proportion tests, and look for trends.

We will also develop a `delta` score that is the difference `DNMT3A meth rate` - `DNMT3B methylation rate`, being methylation rate the `score` resulting from dividing `meth/(meth+unmeth)`.
```{r zscores}

## modified from gCMAP::zScores
zscore_from_pval <- function (pval, direction = NULL, tails = 1, limit = .Machine$double.xmin){ 
    if (!is.null(limit)) {
        pval[which(pval < limit)] <- limit
    }
    if (tails == 2) {
        z <- qnorm(pval/2, lower.tail = FALSE)
    }
    else if (tails == 1) {
        z <- qnorm(pval, lower.tail = FALSE)
    }
    else {
        stop("Parameter 'tails' must be set to either 1 or 2.")
    }

    ## direction of change
    if (!is.null(direction)) {
        z <- z * sign(direction)
    }
    return(z)
}


```


```{r, eval = TRUE, cache = FALSE}

ptests$delta <- a[rownames(ptests), 'score'] - b[rownames(ptests), 'score']
ptests$score_dnmt3a <-  a[rownames(ptests), 'score']
ptests$score_dnmt3b <- b[rownames(ptests), 'score']
ptests$zscore <- zscore_from_pval(ptests$pval, direction = ptests$delta, tails = 2)


```

```{r, fig.width = 8, fig.height = 4}
## plot(ptests)
par(mfrow = c(1,3), pty = 's')

plot(ptests$delta, ptests$zscore, pch = 19)
plot(ptests$score_dnmt3a, ptests$zscore, pch = 19)
plot(ptests$score_dnmt3b, ptests$zscore, pch = 19)

```

Adding the marginal distributions,


```{r}
p <- ggplot(ptests, aes(y = delta, x = zscore)) +
    geom_point() +
    theme_classic(base_size = 20)

ggMarginal(p, type = "histogram", bins = 10, colour = 'black')#, groupColour = TRUE)

```

```{r}
p <- ggplot(ptests, aes(y = score_dnmt3a, x = zscore)) +
    geom_point() +
    theme_classic(base_size = 20)

ggMarginal(p, type = "histogram", bins = 10, colour = 'black')#, groupColour = TRUE)

```

```{r}
p <- ggplot(ptests, aes(y = score_dnmt3b, x = zscore)) +
    geom_point() +
    theme_classic(base_size = 20)

ggMarginal(p, type = "histogram", bins = 10, colour = 'black')#, groupColour = TRUE)

```

```{r}
p <- ggplot(ptests, aes(y = score_dnmt3b, x = score_dnmt3a, color = zscore)) +
    geom_point() +
    theme_classic(base_size = 20)

ggMarginal(p, type = "histogram", bins = 10, colour = 'black')#, groupColour = TRUE)

```


Sort the motifs by their zscore and then the delta of the scores, and plot the trends


```{r}
ptests <- ptests[order(abs(ptests$zscore), ptests$delta,
                               decreasing = TRUE),]
ptests$zscore_rank <- 1:nrow(ptests)
```


```{r}

p <- ggplot(ptests, aes(y = zscore, x = zscore_rank)) +
    geom_point() +
    theme_classic(base_size = 20)

ggMarginal(p, type = "histogram", bins = 10, colour = 'black')
```



```{r}
p <- ggplot(ptests, aes(y = delta, x = zscore_rank)) +
    geom_point() +
    theme_classic(base_size = 20)

ggMarginal(p, type = "histogram", bins = 10, colour = 'black')

```

```{r}
p <- ggplot(ptests, aes(y = score_dnmt3a, x = zscore_rank)) +
    geom_point() +
    theme_classic(base_size = 20)

ggMarginal(p, type = "histogram", bins = 10, colour = 'black')
    
```


```{r}

p <- ggplot(ptests, aes(y = score_dnmt3b, x = zscore_rank)) +
    geom_point() +
    theme_classic(base_size = 20)

ggMarginal(p, type = "histogram", bins = 10, colour = 'black')

```

# All summarized at once


```{r, cache = FALSE}
ptests$motif <- as.character(ptests$motif)
a_motif_perm$motif <- as.character(a_motif_perm$motif)
b_motif_perm$motif <- as.character(b_motif_perm$motif)

ptests <- ptests[a_motif_perm$motif,]
stopifnot(ptests$motif == a_motif_perm$motif)
stopifnot(ptests$motif == b_motif_perm$motif)

summarized <- data.frame(motif = ptests$motif,
                         prop_test_pval = ptests$pval,
                         prop_test_qval = ptests$qval,
                         prop_test_zscore = ptests$zscore,
                         score_dnmt3a = ptests$score_dnmt3a,
                         meth_dnmt3a = a_motif_perm$meth,
                         unmeth_dnmt3a = a_motif_perm$unmeth,
                         pval_permut_motifs_dnmt3a =  a_motif_perm$pval,
                         qval_permut_motifs_dnmt3a =  a_motif_perm$qval,
                         score_dnmt3b = ptests$score_dnmt3b,
                         meth_dnmt3b = b_motif_perm$meth,
                         unmeth_dnmt3b = b_motif_perm$unmeth,
                         pval_permut_motifs_dnmt3b =  b_motif_perm$pval,
                         qval_permut_motifs_dnmt3b =  b_motif_perm$qval)
                         
                         


DT::datatable(summarized %>% as.data.frame() %>% 
              dplyr::mutate_if(is.numeric, funs(round(., 2))), 
              extensions = c("Buttons", "FixedColumns"),
              rownames = FALSE, 
              options = list(dom = "Bfrtip",
                             scrollX = TRUE, 
                             fixedColumns = list(leftColumns = 1),
                             buttons = c("csv", "excel")))
```

# treeclimbR - Clustering-based

Motifs have metastructure, e.g. `AAACGAAA` is closer to `AAACGAAAT` than to `ACGCGCGA`. Let's take into account sequence similarity.

Build a tree based in Levenshtein distances ( https://en.wikipedia.org/wiki/Levenshtein_distance ) implemented as `adist`. 

```{r}

a_dist <- as.data.frame(adist(a_motif_perm$motif, a_motif_perm$motif, counts = TRUE))
colnames(a_dist) <- a_motif_perm$motif
rownames(a_dist) <- a_motif_perm$motif

a_dist[1:10, 1:10]

a_hc <- hclust(d = as.dist(a_dist), method = 'ward.D')

## getting a direction of the pvalue using scores above or below the median
a_motif_perm$direction <- ifelse(a_motif_perm$score >= median(a_motif_perm$score),
                                 yes = +1,
                                 no = -1)

table(a_motif_perm$direction)

```

The distances are as follows:


```{r, eval = FALSE}
DT::datatable(a_dist %>% as.data.frame() %>% 
              dplyr::mutate_if(is.numeric, funs(round(., 2))), 
              extensions = c("Buttons", "FixedColumns"),
              rownames = FALSE, 
              options = list(dom = "Bfrtip",
                             scrollX = TRUE, 
                             fixedColumns = list(leftColumns = 1),
                             buttons = c("csv", "excel")))

```

For AAACGAAA, the edit distances are (one change)

```{r}
names(a_dist[1,a_dist[1,] == 1])
```

Two

```{r}
names(a_dist[1,a_dist[1,] == 2])
```


```{r, fig.height = 5, fig.width = 20}
plot(a_hc)
```


```{r, eval = TRUE}
a_phylo <- as.phylo(a_hc)

```

## DNMT3A

<details><summary>Expand</summary>
```{r dnmt3a_tree, eval = TRUE}

assay_data_dnmt3a <- data.frame(meth = a_motif_perm$meth,
                                unmeth = a_motif_perm$unmeth)

rownames(assay_data_dnmt3a) <- a_motif_perm$motif

row_data_dnmt3a <- DataFrame(motif = a_motif_perm$motif,
                             row.names = rownames(assay_data_dnmt3a))

col_data_dnmt3a <-  DataFrame(group = rep('dnmt3a', 2),
                              measurement = c('meth', 'unmeth'),
                              row.names = colnames(assay_data_dnmt3a))

tse_dnmt3a <- TreeSummarizedExperiment(assays = list(assay_data_dnmt3a),
                                       rowData = row_data_dnmt3a,
                                       colData = col_data_dnmt3a,
                                       rowTree = a_phylo,
                                       rowNodeLab = as.character(summarized$motif))

all_node_dnmt3a <- showNode(tree = rowTree(tse_dnmt3a), only.leaf = FALSE)
tse_dnmt3a <- aggValue(x = tse_dnmt3a, rowLevel = all_node_dnmt3a, FUN = 'sum')


fd_dnmt3a <- data.frame(motif = rownames(as.data.frame(assays(tse_dnmt3a)[[1]])),
                        meth = as.data.frame(assays(tse_dnmt3a)[[1]])$meth,
                        unmeth = as.data.frame(assays(tse_dnmt3a)[[1]])$unmeth)

fd_dnmt3a$score <- fd_dnmt3a$meth / (fd_dnmt3a$meth + fd_dnmt3a$unmeth)

fd_dnmt3a <- run_permutation_test(fd = fd_dnmt3a,
                                  numperm = NUM_PERM,
                                  permutation_type = 'motifs',
                                  adjust.FDR = TRUE)


```

```{r, cache = FALSE}
## sign as being over or above the median for that sample

fd <- fd_dnmt3a

resP_dnmt3a <- list(node = fd$motif,
                    p.value = fd$pval,
                    e.sign = ifelse( fd$score >= median(a_motif_perm$score),
                        yes = +1,
                        no = -1))

outW_dnmt3a <- data.frame(node = rowLinks(tse_dnmt3a)$nodeNum,
                          pvalue = resP_dnmt3a$p.value,
                          sign = resP_dnmt3a$e.sign)

cand_dnmt3a <- getCand(tree = rowTree(tse_dnmt3a), score_data = outW_dnmt3a, 
                       node_column = "node", p_column = "pvalue",
                       sign_column = "sign", message = TRUE)

                                        # evaluate candidates
best_dnmt3a <- evalCand(tree = rowTree(tse_dnmt3a), levels = cand_dnmt3a$candidate_list, 
                        score_data = outW_dnmt3a, node_column = "node",
                        p_column = "pvalue", sign_column = "sign")
best_dnmt3a$level_info

loc_dnmt3a <- best_dnmt3a$output[best_dnmt3a$output$signal.node, ][["node"]]


```
</details>

```{r, fig.width = 20, fig.height = 20, cache = FALSE}

tr <-  rowTree(tse_dnmt3a)
fig_0 <- ggtree(tr, branch.length = "none", layout = "circular", size = 0.5) 

fig_1 <- fig_0 +
    geom_point2(aes(subset = (node %in% loc_dnmt3a)), color = "red", size = 3) +
    geom_tiplab(size=0.8)

print(fig_1)

ggsave(fig_1, file = 'fig1.png', height = 30, width = 30, limitsize = FALSE)

```

```{r, fig.width = 3, fig.height = 20, cache = FALSE}
fig_2 <- ggtree(tr, branch.length = "none", size = 0.1) +
    geom_point2(aes(subset = (node %in% loc_dnmt3a)), color = "red", size = 3) +
    geom_tiplab(size = 0.8)

ggsave(fig_2, file = 'fig2.png', height = 100, width = 10, limitsize = FALSE)

print(fig_2)
```

Subsetting the tree and plotting subtrees with at least 10 leaves.

<details><summary>Expand</summary>

```{r, eval = TRUE, fig.width = 8, fig.height = 2, cache = FALSE}

for (node in loc_dnmt3a) {
    curr <- extract.clade(tr, node, root.edge = 0, collapse.singles = TRUE,
                          interactive = FALSE)

    p1 <- ggtree(curr, branch.length = "none",  size = 0.5) +
        geom_tiplab(size=5) +
        ggtitle(sprintf('DNMT3A\nnode %s', node)) +
        theme(plot.title = element_text(size = 0.5)) +
        ggplot2::xlim(0, 10) # room for the leaves

    p2 <- ggseqlogo(data = curr$tip.label, method ='probability') +
        ggtitle(sprintf('DNMT3A\nnode %s', node)) +
        theme(plot.title = element_text(size = 0.5))

    print(grid.arrange(p1, p2, ncol = 2))
          
}
```

Plus a logo of all significant enrichments of all subtrees

```{r, fig.height = 6, fig.width = 6}
print(ggseqlogo(data = extract.clade(tr, loc_dnmt3a,
                                     root.edge = 0, collapse.singles = TRUE,
                                     interactive = FALSE)$tip.label,
                method = 'probability') +
      ggtitle(sprintf('DNMT3A (tree aggregation FDR < 0.05)')))
```

```{r, fig.height = 6, fig.width = 6}
print(ggseqlogo(data = extract.clade(tr, loc_dnmt3a,
                                     root.edge = 0, collapse.singles = TRUE,
                                     interactive = FALSE)$tip.label,
                method = 'bits') +
      ggtitle(sprintf('DNMT3A (tree aggregation FDR < 0.05)')))
```

## DNMT3B


<details><summary>Expand</summary>

```{r dnmt3b_tree, eval = TRUE, cache = FALSE}

assay_data_dnmt3b <- data.frame(meth = b_motif_perm$meth,
                                unmeth = b_motif_perm$unmeth)

rownames(assay_data_dnmt3b) <- b_motif_perm$motif

row_data_dnmt3b <- DataFrame(motif = b_motif_perm$motif,
                             row.names = rownames(assay_data_dnmt3b))

col_data_dnmt3b <-  DataFrame(group = rep('dnmt3b', 2),
                              measurement = c('meth', 'unmeth'),
                              row.names = colnames(assay_data_dnmt3b))

tse_dnmt3b <- TreeSummarizedExperiment(assays = list(assay_data_dnmt3b),
                                       rowData = row_data_dnmt3b,
                                       colData = col_data_dnmt3b,
                                       rowTree = a_phylo,
                                       rowNodeLab = as.character(summarized$motif))

all_node_dnmt3b <- showNode(tree = rowTree(tse_dnmt3b), only.leaf = FALSE)
tse_dnmt3b <- aggValue(x = tse_dnmt3b, rowLevel = all_node_dnmt3b, FUN = 'sum')


fd_dnmt3b <- data.frame(motif = rownames(as.data.frame(assays(tse_dnmt3b)[[1]])),
                        meth = as.data.frame(assays(tse_dnmt3b)[[1]])$meth,
                        unmeth = as.data.frame(assays(tse_dnmt3b)[[1]])$unmeth)

fd_dnmt3b$score <- fd_dnmt3b$meth / (fd_dnmt3b$meth + fd_dnmt3b$unmeth)

fd_dnmt3b <- run_permutation_test(fd = fd_dnmt3b,
                                  numperm = NUM_PERM,
                                  permutation_type = 'motifs',
                                  adjust.FDR = TRUE)

```


```{r, cache = FALSE}
## sign as being over or above the median for that sample

fd <- fd_dnmt3b
resP_dnmt3b <- list(node = fd$motif,
                    p.value = fd$pval,
                    e.sign = ifelse(as.data.frame(
                        fd$score >= median(b_motif_perm$score),
                        yes = +1,
                        no = -1))

outW_dnmt3b <- data.frame(node = rowLinks(tse_dnmt3b)$nodeNum,
                          pvalue = resP_dnmt3b$p.value,
                          sign = resP_dnmt3b$e.sign)

cand_dnmt3b <- getCand(tree = rowTree(tse_dnmt3b), score_data = outW_dnmt3b, 
                       node_column = "node", p_column = "pvalue",
                       sign_column = "sign", message = TRUE)

                                        # evaluate candidates
best_dnmt3b <- evalCand(tree = rowTree(tse_dnmt3b), levels = cand_dnmt3b$candidate_list, 
                        score_data = outW_dnmt3b, node_column = "node",
                        p_column = "pvalue", sign_column = "sign")
best_dnmt3b$level_info

loc_dnmt3b <- best_dnmt3b$output[best_dnmt3b$output$signal.node, ][["node"]]


```

</details>



```{r, fig.width = 20, fig.height = 20, cache = FALSE}

tr <-  rowTree(tse_dnmt3b)
fig_0 <- ggtree(tr, branch.length = "none", layout = "circular", size = 0.5) 

fig_1 <- fig_0 +
    geom_point2(aes(subset = (node %in% loc_dnmt3b)), color = "red", size = 3) +
    geom_tiplab(size=0.8)

print(fig_1)

ggsave(fig_1, file = 'fig1b.png', height = 30, width = 30, limitsize = FALSE)

```

```{r, fig.width = 3, fig.height = 20}
fig_2 <- ggtree(tr, branch.length = "none", size = 0.1) +
    geom_point2(aes(subset = (node %in% loc_dnmt3b)), color = "red", size = 3) +
    geom_tiplab(size = 0.8)

ggsave(fig_2, file = 'fig2b.png', height = 100, width = 10, limitsize = FALSE)

print(fig_2)
```

Subsetting the tree and plotting subtrees with at least 10 leaves.

<details><summary>Expand</summary>

```{r, eval = TRUE, fig.width = 8, fig.height = 2, cache = FALSE}

for (node in loc_dnmt3b) {
    curr <- extract.clade(tr, node, root.edge = 0, collapse.singles = TRUE,
                          interactive = FALSE)

    p1 <- ggtree(curr, branch.length = "none",  size = 0.5) +
        geom_tiplab(size=5) +
        ggtitle(sprintf('DNMT3B\nnode %s', node)) +
        theme(plot.title = element_text(size = 0.5)) +
        ggplot2::xlim(0, 10) # room for the leaves

    p2 <- ggseqlogo(data = curr$tip.label, method ='probability') +
        ggtitle(sprintf('DNMT3B\nnode %s', node)) +
        theme(plot.title = element_text(size = 0.5))

    print(grid.arrange(p1, p2, ncol = 2))
          
}
```

Plus a logo of all significant enrichments of all subtrees

```{r, fig.height = 6, fig.width = 6, cache = FALSE}
print(ggseqlogo(data = extract.clade(tr, loc_dnmt3b,
                                     root.edge = 0, collapse.singles = TRUE,
                                     interactive = FALSE)$tip.label,
                method = 'probability') +
      ggtitle(sprintf('DNMT3B (tree aggregation FDR < 0.05)')))
```

```{r, fig.height = 6, fig.width = 6, cache = FALSE}
print(ggseqlogo(data = extract.clade(tr, loc_dnmt3b,
                                     root.edge = 0, collapse.singles = TRUE,
                                     interactive = FALSE)$tip.label,
                method = 'bits') +
      ggtitle(sprintf('DNMT3B (tree aggregation FDR < 0.05)')))
```



<!-- ```{r} -->

<!-- tr <-  rowTree(tse_dnmt3b) -->
<!-- fig_0 <- ggtree(tr, branch.length = "none", layout = "circular", size = 0.5) -->

<!-- fig_1 <- fig_0 + -->
<!--     geom_point2(aes(subset = (node %in% loc_dnmt3b)), color = "red", size = 1) + -->
<!--     geom_tiplab(size=0.8) -->

<!-- print(fig_1) -->

<!-- ggsave(fig_1, file = 'fig1b.png', height = 30, width = 30, limitsize = FALSE) -->

<!-- ``` -->

<!-- ```{r} -->
<!-- fig_2 <- ggtree(tr, branch.length = "none", size = 0.5) + -->
<!--     geom_point2(aes(subset = (node %in% loc_dnmt3b)), color = "red", size = 5) + -->
<!--     geom_tiplab(size = 0.8) -->

<!-- ggsave(fig_2, file = 'fig2b.png', height = 100, width = 10, limitsize = FALSE) -->

<!-- print(fig_2) -->
<!-- ``` -->


<!-- Subsetting the tree and plotting subtrees with at least 10 leaves. -->

<!-- <details><summary>Expand</summary> -->

<!-- ```{r, fig.width = 1, fig.height = 1, eval = TRUE} -->

<!-- for (node in loc_dnmt3b) { -->
<!--     curr <- extract.clade(tr, node, root.edge = 0, collapse.singles = TRUE, -->
<!--                           interactive = FALSE) -->

<!--         print(ggtree(curr, branch.length = "none", layout = "circular", size = 0.5) + -->
<!--               geom_tiplab(size=0.8) +  -->
<!--               ggtitle(sprintf('DNMT3A node %s', node))) -->

<!--         ## seqlogo -->
<!-- } -->

<!-- ``` -->

<!-- ```{r} -->
<!-- library(ggseqlogo) -->
<!-- for (node in loc_dnmt3b) { -->
<!--     curr <- extract.clade(tr, node, root.edge = 0, collapse.singles = TRUE, -->
<!--                           interactive = FALSE) -->

<!--     print(ggseqlogo(data = curr$tip.label, method ='probability')) -->

<!--         ## seqlogo -->
<!-- } -->

<!-- ``` -->

<!-- </details> -->

## Trying to plot all at once, including the signal sign

```{r, fig.width = 4, fig.height = 20, cache = FALSE}

tr <- rowTree(tse_dnmt3a) ## actually it would be the same with tse_dnmt3b

## leaves only!
leaves <- showNode(tree = rowTree(tse_dnmt3b), only.leaf = TRUE)

## as compared to the median of each dataset
high_in_dnmt3a <- intersect(resP_dnmt3a$node[resP_dnmt3a$e.sign == '1'], leaves)
high_in_dnmt3b <- intersect(resP_dnmt3a$node[resP_dnmt3b$e.sign == '1'], leaves)
high_in_both <- intersect(high_in_dnmt3a, high_in_dnmt3b)

tip_annot <- data.frame(node = showNode(tr, only.leaf = TRUE),
                        cat = 'low',
                        stringsAsFactors = FALSE)

rownames(tip_annot) <- tip_annot$node

tip_annot$cat <- ifelse(test = tip_annot$node %in% high_in_dnmt3a,
                        yes = 'high_in_dnmt3a',
                        no = 'low')

tip_annot$cat[tip_annot$node %in% high_in_dnmt3b] <- 'high_in_dnmt3b'
tip_annot$cat[tip_annot$node %in% high_in_both] <- 'high_in_both'

table(tip_annot$cat)
```


```{r, fig.width = 4, fig.height = 30}
fig_int <- ggtree(tr, branch.length = "none", size = 0.2)

fig_int2 <- fig_int %<+% tip_annot + 
    geom_tiplab(aes(fill = factor(cat)),
                color = "black", # color for label font
                geom = "label",  # labels not text
                size  = 0.8,
                label.padding = unit(0, "lines"), # amount of padding around the labels
                label.size = 0) + # size of label border
    geom_point2(aes(subset = (node %in% loc_dnmt3a)),
                color = "forestgreen", size = 2, shape = 17) +
    geom_point2(aes(subset = (node %in% loc_dnmt3b)),
                color = "turquoise", size = 2) +
    theme(legend.position = "top", 
          legend.title = element_blank(), # no title
          legend.key = element_blank()) + # no keys +
    guides(fill=guide_legend(nrow=2, byrow=TRUE))


print(fig_int2)

ggsave(fig_int2, file = 'fig_int2.png', height = 100, width = 12, limitsize = FALSE)

```

## Random background (for DNMT3A)

Fiona Huang suggestion start

```{r, cache = FALSE}
set.seed(45)
a_phylorandom <- rtree(4096)

set.seed(54)
a_phylorandom$tip.label <- sample(rownames(a), size = nrow(a), replace = FALSE)

```

And run the method

```{r, fig.height = 20, fig.width = 4}

cand_random_dnmt3a <- getCand(tree = a_phylorandom, score_data = outW_dnmt3a, 
                       node_column = "node", p_column = "pvalue",
                       sign_column = "sign", message = TRUE)

## evaluate candidates
best_random_dnmt3a <- evalCand(tree = a_phylorandom,
                               levels = cand_dnmt3a$candidate_list, 
                        score_data = outW_dnmt3a, node_column = "node",
                        p_column = "pvalue", sign_column = "sign")

print(best_random_dnmt3a$level_info)

loc_random_dnmt3a <- best_random_dnmt3a$output[best_random_dnmt3a$output$signal.node, ][["node"]]

## print(loc_random_dnmt3a)
```


```{r, fig.width = 20, fig.height = 20, cache = FALSE}


fig_0 <- ggtree(a_phylorandom, branch.length = "none", layout = "circular", size = 0.5) 

fig_1 <- fig_0 +
    geom_point2(aes(subset = (node %in% loc_random_dnmt3a)), color = "red", size = 3) +
    geom_tiplab(size=0.8)

print(fig_1)
```

Fiona Huang suggestion end

```{r}
## a_fiona <- a_motif_perm
save(tse_dnmt3a, file = 'tse_dnmt3a_fiona.Rdata')


```


## Random background (for DNMT3A)

Witout leaves randomization, only topology (randomizing twice might result in clustering again).


```{r, cache = FALSE}
set.seed(45)
a_phylorandom <- rtree(4096)

set.seed(54)
a_phylorandom$tip.label <- rownames(a_motif_perm)

```

And run the method

```{r, fig.height = 20, fig.width = 4, cache = FALSE}

cand_random_dnmt3a <- getCand(tree = a_phylorandom, score_data = outW_dnmt3a, 
                       node_column = "node", p_column = "pvalue",
                       sign_column = "sign", message = TRUE)

## evaluate candidates
best_random_dnmt3a <- evalCand(tree = a_phylorandom,
                               levels = cand_dnmt3a$candidate_list, 
                        score_data = outW_dnmt3a, node_column = "node",
                        p_column = "pvalue", sign_column = "sign")

print(best_random_dnmt3a$level_info)

loc_random_dnmt3a <- best_random_dnmt3a$output[best_random_dnmt3a$output$signal.node, ][["node"]]

## print(loc_random_dnmt3a)
```


```{r, fig.width = 20, fig.height = 20, cache = FALSE}


fig_0 <- ggtree(a_phylorandom, branch.length = "none", layout = "circular", size = 0.5) 

fig_1 <- fig_0 +
    geom_point2(aes(subset = (node %in% loc_random_dnmt3a)), color = "red", size = 3) +
    geom_tiplab(size=0.8)

print(fig_1)
```

# Timestamp

```{r sessionInfo, cache = 0}
date()
sessionInfo()
devtools::session_info()

```
